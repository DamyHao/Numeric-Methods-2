close all;
clc;
clear all;

figure
p = @(x)(0 .* x + 1); % En cas que sigui una funcio constant, cal que apareixi la x en el function handler
q = @(x)(0 .* x + 1);
r = @(x)(0 .* x + 100);
g = @(x)(1 .* x);
n = 1280;
CC = [1, 0, 0; 1, 0, 0];
a = -1; b = 1;
[f, x] = resoldreODE(n, CC, p, q, r, g, a, b);
plot(x(2:end-1), f, '-k.');

figure
p = @(x)(0 .* x + 1); % En cas que sigui una funcio constant, cal que apareixi la x en el function handler
q = @(x)(0 .* x + 1);
r = @(x)(0 .* x + 100);
g = @(x)(1 .* x);
n = 1280;
CC = [0, 1, 0; 0, 1, 0];
a = -1; b = 1;
[f, x] = resoldreODE(n, CC, p, q, r, g, a, b);
plot(x(2:end-1), f, '-k.');

%% Exercici 2:
close all
format long g;

v0 = [-2.5; -2.5];

[XK, resd, it] = newtonn(v0, 1e-6, 150, @newtonFunction);
XK(:, end)

v0 = [-2.5; 2.5];
% C
[XK2, resd, it] = newtonn(v0, 1e-10, 150, @newtonFunction);
XK2(:, end)

v0 = [-2.5; 0];

[XK3, resd, it] = newtonn(v0, 1e-9, 150, @newtonFunction);
XK3(:, end)


h = 0.01;
vn0 = [0;-2.8 ; 0 ; 3.1 ;0];
finalTime = 60;
   %   Tfinal sera vn(0) + h*(desiredPoints-1)
desiredPoints = finalTime/h + 2;
V = RK4wTime(vn0, h, @rkFun, desiredPoints);

figure;
vn0 = [0;-2.8 ; 0 ; 3.1 ;0];
finalTime = 5;
desiredPoints = finalTime/h + 1;
V2 = RK4wTime(vn0, h, @rkFun, desiredPoints);
plot(V2(1,:), V2(2,:));

figure;

xt = V2(2,1:end)';

N = length(xt);
%xt = sin(1:N);
fourierSpace = dftmat(xt);
k = -N/2:(N/2-1);
wk = 2*pi/(N*h).*k; %spectrum of frequencies
semilogy(wk, abs(fourierSpace));


XK2(:, end);
xEqui = [XK(1,end), 0 , XK(2, end), 0];
xEqui2 = [XK2(1,end); 0 ; XK2(2, end); 0];
DF = jaco(@rkFun, xEqui);
DF2 = jaco(@rkFun, xEqui2);
[VEC, VAL] = eig(DF2);
disp(abs(diag(VAL)))

%Posarem 0.9999999 i farem variar el angle
solutions = [];
for angle = 0:0.01:2*pi
    initialT = 0.9999999;
    x0 = [angle; initialT];
    [XK, resd, it] = newtonn(x0, 1e-10, 100, @finishAtOne);
    if(solutio
    solutions =  [solutions, XK(:, end)];
end


function distToC = finishAtOne(in)
v0mod = 17;
px = v0mod*cos(in(1));
py = v0mod*sin(in(1));
vn0 = [0;-3.779310253377747 ; px ; -3.283185991286169 ; py];

if 0 < in(2) < 1
    h = 0.01;
    desiredPoints = in(2)/h + 1;
    VTemp = RK4wTime(vn0, h, @rkFun, desiredPoints);
    C = [-2.805118086952745 , 3.131312518250573 ];
    distToC = norm(VTemp(2:end,end)-C);
else % If time is greater than 2, we will introduce an "artificial slope" to help newton to converge to r = (0,0)
    % If we launch newton to the correct point we will not reach this code:
    disp('Surpasing t = 1');
    distToC = in(2);
end
end

function r = funForNewton(z)
    % Function to launch newtonn
    % Input: z is a vector of two components, the first one corresponds to
    % the launch angle of the particle and the second one to the time that it
    % takes to get to the origin
    % Output: the distance to the origin. Newton will make it 0.
    initial = [0; -3.779310253377747; sqrt(2) .* cos(z(1)); sqrt(2) .* sin(z(1))]; % initial point to launch RK4
    steps = 20000; %h will be smaller than 0.0001 since we the time to be < 2

    if 0 < z(2) < 2
        h = z(2) / steps;
        sol = RK4(initial, h, @gravFunctionV, steps + 1);
        r = sol(1:2, end);
    else % If time is greater than 2, we will introduce an "artificial slope" to help newton to converge to r = (0,0)
         % If we launch newton to the correct point we will not reach this code:
        disp('Surpasing t = 2');
        r = [1; 1]*z(2);
    end
end